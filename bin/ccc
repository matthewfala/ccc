#!/usr/bin/env bash
#
# ccc - Claude Code Container
# A tool to run Claude Code in a sandboxed Docker container
#
# Copyright (c) Matthew Fala. All Rights Reserved.
#

set -euo pipefail

# Configuration
CCC_VERSION="1.1.5"
CCC_IMAGE_PREFIX="ccc-devcontainer"
CCC_SECRETS_BASE="${HOME}/Sandbox/ccc-secrets"
CCC_CLAUDE_CONFIG_DIR="${HOME}/.ccc-claude-config"
CCC_CLAUDE_NODEJS_DIR="${HOME}/.ccc-nodejs-config"
CCC_XDG_CONFIG_DIR="${HOME}/.ccc-xdg-config"
CCC_XDG_DATA_DIR="${HOME}/.ccc-xdg-data"

# Colors for output (if terminal supports it)
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Print functions
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Show usage
show_usage() {
    cat << EOF
ccc - Claude Code Container v${CCC_VERSION}

Usage: ccc [OPTIONS] [COMMAND]

Run Claude Code in a sandboxed Docker container with access only to the current directory.

Options:
    -h, --help          Show this help message
    -v, --version       Show version information
    -b, --build         Force rebuild of the Docker image
    -n, --no-network    Restrict network access (enable firewall)
    --shell             Open a shell instead of Claude Code

Commands:
    init                Initialize ccc in current directory (creates /ccc folder)
    build               Build/rebuild the Docker image
    clean               Remove Docker image and container for current project
    status              Show status of current project

Examples:
    ccc                 Start Claude Code in the current directory
    ccc init            Initialize ccc configuration in current directory
    ccc --build         Force rebuild and start Claude Code
    ccc --shell         Open an interactive shell in the container

For more information, visit: https://github.com/anthropics/claude-code

EOF
}

# Get project name from current directory
get_project_name() {
    basename "$(pwd)"
}

# Get image name for current project
get_image_name() {
    local project_name
    project_name=$(get_project_name)
    echo "${CCC_IMAGE_PREFIX}-${project_name}"
}

# Get container name for current project
get_container_name() {
    local project_name
    project_name=$(get_project_name)
    echo "ccc-${project_name}"
}

# Check if Docker is available
check_docker() {
    if ! command -v docker &> /dev/null; then
        print_error "Docker is not installed or not in PATH"
        print_info "Please install Docker: https://docs.docker.com/get-docker/"
        exit 1
    fi

    if ! docker info &> /dev/null; then
        print_error "Docker daemon is not running"
        print_info "Please start Docker and try again"
        exit 1
    fi
}

# Initialize ccc in current directory
init_project() {
    local project_name
    project_name=$(get_project_name)
    local ccc_dir="./ccc"
    local secrets_dir="${CCC_SECRETS_BASE}/${project_name}"

    print_info "Initializing ccc for project: ${project_name}"

    # Create ccc directory
    if [[ ! -d "${ccc_dir}" ]]; then
        mkdir -p "${ccc_dir}"
        print_success "Created ${ccc_dir} directory"
    else
        print_info "${ccc_dir} directory already exists"
    fi

    # Create Dockerfile.devcontainer if it doesn't exist
    if [[ ! -f "${ccc_dir}/Dockerfile.devcontainer" ]]; then
        create_default_dockerfile "${ccc_dir}/Dockerfile.devcontainer"
        print_success "Created ${ccc_dir}/Dockerfile.devcontainer"
    else
        print_info "Dockerfile.devcontainer already exists"
    fi

    # Create init-firewall.sh if it doesn't exist
    if [[ ! -f "${ccc_dir}/init-firewall.sh" ]]; then
        create_init_firewall_script "${ccc_dir}/init-firewall.sh"
        print_success "Created ${ccc_dir}/init-firewall.sh"
    else
        print_info "init-firewall.sh already exists"
    fi

    # Create entrypoint.sh if it doesn't exist
    if [[ ! -f "${ccc_dir}/entrypoint.sh" ]]; then
        create_entrypoint_script "${ccc_dir}/entrypoint.sh"
        print_success "Created ${ccc_dir}/entrypoint.sh"
    else
        print_info "entrypoint.sh already exists"
    fi

    # Create steering file
    if [[ ! -f "${ccc_dir}/CLAUDE.md" ]]; then
        create_steering_file "${ccc_dir}/CLAUDE.md" "${project_name}"
        print_success "Created ${ccc_dir}/CLAUDE.md steering file"
    else
        print_info "CLAUDE.md steering file already exists"
    fi

    # Create secrets directory on host
    if [[ ! -d "${secrets_dir}" ]]; then
        mkdir -p "${secrets_dir}"
        print_success "Created secrets directory: ${secrets_dir}"
    else
        print_info "Secrets directory already exists: ${secrets_dir}"
    fi

    # Create .gitignore if not exists
    if [[ ! -f "${ccc_dir}/.gitignore" ]]; then
        cat > "${ccc_dir}/.gitignore" << 'GITIGNORE'
# CCC local files
*.local
.env
GITIGNORE
        print_success "Created ${ccc_dir}/.gitignore"
    fi

    print_success "Project initialized! Run 'ccc' to start Claude Code in container"
}

# Create the default Dockerfile
create_default_dockerfile() {
    local dockerfile_path="$1"
    cat > "${dockerfile_path}" << 'DOCKERFILE'
FROM node:20

ARG TZ
ENV TZ="$TZ"

ARG CLAUDE_CODE_VERSION=latest

# Install basic development tools, iptables/ipset, and Docker CLI for Docker-in-Docker
RUN apt-get update && apt-get install -y --no-install-recommends \
    less \
    git \
    procps \
    sudo \
    fzf \
    zsh \
    man-db \
    unzip \
    gnupg2 \
    gh \
    iptables \
    ipset \
    iproute2 \
    dnsutils \
    aggregate \
    jq \
    nano \
    vim \
    ca-certificates \
    curl \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# Install Docker CLI for Docker-in-Docker support
RUN install -m 0755 -d /etc/apt/keyrings && \
    curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc && \
    chmod a+r /etc/apt/keyrings/docker.asc && \
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian $(. /etc/os-release && echo "$VERSION_CODENAME") stable" > /etc/apt/sources.list.d/docker.list && \
    apt-get update && \
    apt-get install -y --no-install-recommends docker-ce-cli docker-buildx-plugin gosu && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

# Ensure default node user has access to /usr/local/share
RUN mkdir -p /usr/local/share/npm-global && \
    chown -R node:node /usr/local/share

ARG USERNAME=node

# Persist bash history
RUN SNIPPET="export PROMPT_COMMAND='history -a' && export HISTFILE=/commandhistory/.bash_history" \
    && mkdir /commandhistory \
    && touch /commandhistory/.bash_history \
    && chown -R $USERNAME /commandhistory

# Set DEVCONTAINER environment variable
ENV DEVCONTAINER=true

# Auto-accept Claude Code terms and dangerous permissions since we're in a container
ENV CLAUDE_CODE_ACCEPT_TOS=true

# Create workspace, secrets, and config directories (including XDG paths for persistent config)
RUN mkdir -p /sandbox /secrets /home/node/.claude /home/node/.config /home/node/.local/share /home/node/.npm && \
    chown -R node:node /sandbox /secrets /home/node/.claude /home/node/.config /home/node/.local /home/node/.npm

# Set XDG environment variables for config persistence
ENV XDG_CONFIG_HOME=/home/node/.config
ENV XDG_DATA_HOME=/home/node/.local/share

WORKDIR /sandbox

ARG GIT_DELTA_VERSION=0.18.2
RUN ARCH=$(dpkg --print-architecture) && \
    wget "https://github.com/dandavison/delta/releases/download/${GIT_DELTA_VERSION}/git-delta_${GIT_DELTA_VERSION}_${ARCH}.deb" && \
    sudo dpkg -i "git-delta_${GIT_DELTA_VERSION}_${ARCH}.deb" && \
    rm "git-delta_${GIT_DELTA_VERSION}_${ARCH}.deb"

# Set up non-root user
USER node

# Install global packages
ENV NPM_CONFIG_PREFIX=/usr/local/share/npm-global
ENV PATH=$PATH:/usr/local/share/npm-global/bin

# Set the default shell to zsh
ENV SHELL=/bin/zsh

# Set the default editor
ENV EDITOR=nano
ENV VISUAL=nano

# Default powerline10k theme
ARG ZSH_IN_DOCKER_VERSION=1.2.0
RUN sh -c "$(wget -O- https://github.com/deluan/zsh-in-docker/releases/download/v${ZSH_IN_DOCKER_VERSION}/zsh-in-docker.sh)" -- \
    -p git \
    -p fzf \
    -a "source /usr/share/doc/fzf/examples/key-bindings.zsh" \
    -a "source /usr/share/doc/fzf/examples/completion.zsh" \
    -a "export PROMPT_COMMAND='history -a' && export HISTFILE=/commandhistory/.bash_history" \
    -x

# Install Claude Code
RUN npm install -g @anthropic-ai/claude-code@${CLAUDE_CODE_VERSION}

# Copy and set up firewall script and entrypoint
COPY init-firewall.sh /usr/local/bin/
COPY entrypoint.sh /usr/local/bin/
USER root
RUN chmod +x /usr/local/bin/init-firewall.sh /usr/local/bin/entrypoint.sh && \
    echo "node ALL=(root) NOPASSWD: /usr/local/bin/init-firewall.sh" > /etc/sudoers.d/node-firewall && \
    echo "node ALL=(root) NOPASSWD: ALL" > /etc/sudoers.d/node-sudo && \
    chmod 0440 /etc/sudoers.d/node-firewall && \
    chmod 0440 /etc/sudoers.d/node-sudo

# Use entrypoint to fix docker socket permissions before switching to node user
ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]

# Default command
CMD ["claude", "--dangerously-skip-permissions"]
DOCKERFILE
}

# Create init-firewall.sh script
create_init_firewall_script() {
    local script_path="$1"
    cat > "${script_path}" << 'FIREWALL_SCRIPT'
#!/bin/bash
set -euo pipefail
IFS=$'\n\t'

# Extract Docker DNS info BEFORE any flushing
DOCKER_DNS_RULES=$(iptables-save -t nat | grep "127\.0\.0\.11" || true)

# Flush existing rules and delete existing ipsets
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
ipset destroy allowed-domains 2>/dev/null || true

# Restore Docker DNS resolution
if [ -n "$DOCKER_DNS_RULES" ]; then
    echo "Restoring Docker DNS rules..."
    iptables -t nat -N DOCKER_OUTPUT 2>/dev/null || true
    iptables -t nat -N DOCKER_POSTROUTING 2>/dev/null || true
    echo "$DOCKER_DNS_RULES" | xargs -L 1 iptables -t nat
else
    echo "No Docker DNS rules to restore"
fi

# Allow DNS and localhost before restrictions
iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
iptables -A INPUT -p udp --sport 53 -j ACCEPT
iptables -A OUTPUT -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# Create ipset with CIDR support
ipset create allowed-domains hash:net

# Fetch GitHub meta information
echo "Fetching GitHub IP ranges..."
gh_ranges=$(curl -s https://api.github.com/meta)
if [ -z "$gh_ranges" ]; then
    echo "ERROR: Failed to fetch GitHub IP ranges"
    exit 1
fi

if ! echo "$gh_ranges" | jq -e '.web and .api and .git' >/dev/null; then
    echo "ERROR: GitHub API response missing required fields"
    exit 1
fi

echo "Processing GitHub IPs..."
while read -r cidr; do
    if [[ ! "$cidr" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$ ]]; then
        echo "ERROR: Invalid CIDR range from GitHub meta: $cidr"
        exit 1
    fi
    echo "Adding GitHub range $cidr"
    ipset add allowed-domains "$cidr"
done < <(echo "$gh_ranges" | jq -r '(.web + .api + .git)[]' | aggregate -q)

# Resolve and add other allowed domains
for domain in \
    "registry.npmjs.org" \
    "api.anthropic.com" \
    "sentry.io" \
    "statsig.anthropic.com" \
    "statsig.com" \
    "marketplace.visualstudio.com" \
    "vscode.blob.core.windows.net" \
    "update.code.visualstudio.com"; do
    echo "Resolving $domain..."
    ips=$(dig +noall +answer A "$domain" | awk '$4 == "A" {print $5}')
    if [ -z "$ips" ]; then
        echo "ERROR: Failed to resolve $domain"
        exit 1
    fi

    while read -r ip; do
        if [[ ! "$ip" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            echo "ERROR: Invalid IP from DNS for $domain: $ip"
            exit 1
        fi
        echo "Adding $ip for $domain"
        ipset add allowed-domains "$ip"
    done < <(echo "$ips")
done

# Get host IP from default route
HOST_IP=$(ip route | grep default | cut -d" " -f3)
if [ -z "$HOST_IP" ]; then
    echo "ERROR: Failed to detect host IP"
    exit 1
fi

HOST_NETWORK=$(echo "$HOST_IP" | sed "s/\.[0-9]*$/.0\/24/")
echo "Host network detected as: $HOST_NETWORK"

# Set up remaining iptables rules
iptables -A INPUT -s "$HOST_NETWORK" -j ACCEPT
iptables -A OUTPUT -d "$HOST_NETWORK" -j ACCEPT

# Set default policies to DROP
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT DROP

# Allow established connections
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Allow outbound traffic to allowed domains
iptables -A OUTPUT -m set --match-set allowed-domains dst -j ACCEPT

# Reject other outbound traffic
iptables -A OUTPUT -j REJECT --reject-with icmp-admin-prohibited

echo "Firewall configuration complete"
FIREWALL_SCRIPT
    chmod +x "${script_path}"
}

# Create entrypoint script that fixes docker socket permissions
create_entrypoint_script() {
    local script_path="$1"
    cat > "${script_path}" << 'ENTRYPOINT_SCRIPT'
#!/bin/bash
set -e

# Fix docker socket permissions if it exists
if [ -S /var/run/docker.sock ]; then
    chmod 666 /var/run/docker.sock 2>/dev/null || true
fi

# Fix ownership of mounted config directories so node user can write to them
chown -R node:node /home/node/.claude 2>/dev/null || true
chown -R node:node /home/node/.config 2>/dev/null || true
chown -R node:node /home/node/.local 2>/dev/null || true
chown -R node:node /home/node/.npm 2>/dev/null || true

# Ensure the directories exist with correct permissions
mkdir -p /home/node/.claude /home/node/.config /home/node/.local/share /home/node/.npm
chown -R node:node /home/node/.claude /home/node/.config /home/node/.local /home/node/.npm

# Switch to node user and execute the command
exec gosu node "$@"
ENTRYPOINT_SCRIPT
    chmod +x "${script_path}"
}

# Create steering file for Claude Code
create_steering_file() {
    local steering_path="$1"
    local project_name="$2"
    cat > "${steering_path}" << STEERING
# Claude Code Container Steering File

## Container Environment

You are running inside a sandboxed Docker container via **ccc** (Claude Code Container).
Your workspace is mounted at \`/sandbox\` which corresponds to the host's project directory.

## Important Guidelines

### File System Restrictions
- You can ONLY modify files within \`/sandbox\` (the mounted project directory)
- Do NOT attempt to modify system files or directories outside \`/sandbox\`
- All your work should be contained within the project directory

### Secrets Management
- A secrets directory is mounted at \`/secrets\` for storing sensitive data
- Use \`/secrets\` for API keys, credentials, and other sensitive information that should NOT be committed to git
- The secrets directory persists between container restarts
- Location on host: \`~/Sandbox/ccc-secrets/${project_name}\`

### Container OS Changes (Docker-in-Docker) - AUTOMATIC PERSISTENCE

**IMPORTANT**: When you install any software or tools that need to persist across container restarts, you MUST:

1. **Automatically edit the Dockerfile**: Modify \`/sandbox/ccc/Dockerfile.devcontainer\` to add the required packages
2. **Document changes**: Add comments explaining why each package is needed
3. **Rebuild from within the container**: Use Docker-in-Docker to rebuild the image:
   \`\`\`bash
   cd /sandbox/ccc && docker build -t ccc-devcontainer-\$(basename /sandbox) -f Dockerfile.devcontainer .
   \`\`\`
4. **If the build fails**: Fix the Dockerfile and try rebuilding again until successful

**This decision to persist software should be made AUTOMATICALLY by you. Do NOT ask the user if they want to persist - just do it.**

Example addition to Dockerfile:
\`\`\`dockerfile
# Install Python for data processing scripts
RUN apt-get update && apt-get install -y python3 python3-pip && \\
    apt-get clean && rm -rf /var/lib/apt/lists/*
\`\`\`

Docker is available inside this container via Docker-in-Docker. The docker socket permissions are automatically configured at container startup.

### Network Access
- By default, network access is unrestricted
- If running with \`--no-network\`, only specific domains are accessible:
  - api.anthropic.com
  - github.com
  - registry.npmjs.org
  - And a few others for essential operations

### Best Practices
1. Keep all project files in \`/sandbox\`
2. Store secrets in \`/secrets\`, never in the project directory
3. Document any Dockerfile changes clearly
4. Avoid modifying container state directly; prefer Dockerfile changes for persistence

## Project Structure
\`\`\`
/sandbox/                    # Your project (mounted from host)
├── ccc/
│   ├── Dockerfile.devcontainer  # Customize your container here
│   ├── init-firewall.sh         # Network firewall script
│   └── CLAUDE.md                # This steering file
├── [your project files]
/secrets/                    # Persistent secrets storage (mounted)
\`\`\`
STEERING
}

# Ensure steering file exists at project root for Claude to read
ensure_steering_file_at_root() {
    local project_name
    project_name=$(get_project_name)
    local ccc_dir="./ccc"
    local root_steering_file="./CLAUDE.md"
    local ccc_steering_file="${ccc_dir}/CLAUDE.md"

    # If CCC steering file doesn't exist, create it
    if [[ ! -f "${ccc_steering_file}" ]]; then
        mkdir -p "${ccc_dir}"
        create_steering_file "${ccc_steering_file}" "${project_name}"
    fi

    # Create/update symlink or copy at project root if it doesn't exist or is outdated
    if [[ ! -f "${root_steering_file}" ]]; then
        # Create symlink to ccc steering file at project root
        ln -sf "ccc/CLAUDE.md" "${root_steering_file}"
        print_info "Created steering file symlink at project root: ${root_steering_file}"
    elif [[ -L "${root_steering_file}" ]]; then
        # It's already a symlink, verify it points to our file
        local target
        target=$(readlink "${root_steering_file}" 2>/dev/null || echo "")
        if [[ "${target}" != "ccc/CLAUDE.md" ]]; then
            print_warning "CLAUDE.md exists but points elsewhere. Steering file in ccc/CLAUDE.md available."
        fi
    else
        # It's a regular file, don't overwrite - just inform
        print_info "Project has custom CLAUDE.md. Container steering available in ccc/CLAUDE.md"
    fi
}

# Ensure all required ccc files exist (for upgrades from older versions)
ensure_ccc_files() {
    local ccc_dir="./ccc"
    local project_name
    project_name=$(get_project_name)

    # Always update entrypoint.sh to get latest fixes (small generated file)
    create_entrypoint_script "${ccc_dir}/entrypoint.sh"

    # Ensure init-firewall.sh exists
    if [[ ! -f "${ccc_dir}/init-firewall.sh" ]]; then
        create_init_firewall_script "${ccc_dir}/init-firewall.sh"
        print_info "Created missing ${ccc_dir}/init-firewall.sh"
    fi
}

# Build Docker image
build_image() {
    local force_build="${1:-false}"
    local project_name
    project_name=$(get_project_name)
    local image_name
    image_name=$(get_image_name)
    local ccc_dir="./ccc"

    # Check if ccc is initialized
    if [[ ! -d "${ccc_dir}" ]]; then
        print_warning "Project not initialized. Running init first..."
        init_project
    else
        # Ensure all required files exist (handles upgrades from older versions)
        ensure_ccc_files
    fi

    # Check if image exists and we're not forcing rebuild
    if [[ "${force_build}" != "true" ]] && docker image inspect "${image_name}" &> /dev/null; then
        print_info "Image ${image_name} already exists. Use --build to force rebuild."
        return 0
    fi

    print_info "Building Docker image: ${image_name}"

    # Build the image
    docker build \
        --build-arg TZ="$(cat /etc/timezone 2>/dev/null || echo 'UTC')" \
        -t "${image_name}" \
        -f "${ccc_dir}/Dockerfile.devcontainer" \
        "${ccc_dir}"

    print_success "Image built successfully: ${image_name}"
}

# Run Claude Code in container
run_container() {
    local shell_mode="${1:-false}"
    local no_network="${2:-false}"
    local project_name
    project_name=$(get_project_name)
    local image_name
    image_name=$(get_image_name)
    local container_name
    container_name=$(get_container_name)
    local secrets_dir="${CCC_SECRETS_BASE}/${project_name}"

    # Ensure image is built
    build_image "false"

    # Ensure secrets directory exists
    mkdir -p "${secrets_dir}"

    # Ensure Claude config directory exists
    mkdir -p "${CCC_CLAUDE_CONFIG_DIR}"

    # Ensure Node.js config directory exists (for npm cache and global packages)
    mkdir -p "${CCC_CLAUDE_NODEJS_DIR}"

    # Ensure XDG config directories exist (for Claude Code settings persistence)
    mkdir -p "${CCC_XDG_CONFIG_DIR}"
    mkdir -p "${CCC_XDG_DATA_DIR}"

    # Ensure steering file exists at project root for Claude to read on startup
    ensure_steering_file_at_root

    # Display version on startup
    echo ""
    echo -e "${BLUE}╔══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║${NC}       ${GREEN}Claude Code Container (ccc) v${CCC_VERSION}${NC}               ${BLUE}║${NC}"
    echo -e "${BLUE}║${NC}       Project: ${YELLOW}${project_name}${NC}                              ${BLUE}║${NC}"
    echo -e "${BLUE}╚══════════════════════════════════════════════════════════╝${NC}"
    echo ""

    print_info "Starting Claude Code Container for: ${project_name}"

    # Build docker run command
    local docker_args=(
        run
        --rm
        -it
        --name "${container_name}"
        -v "$(pwd):/sandbox"
        -v "${secrets_dir}:/secrets"
        -v "${CCC_CLAUDE_CONFIG_DIR}:/home/node/.claude"
        -v "${CCC_CLAUDE_NODEJS_DIR}:/home/node/.npm"
        -v "${CCC_XDG_CONFIG_DIR}:/home/node/.config"
        -v "${CCC_XDG_DATA_DIR}:/home/node/.local/share"
        -v "/var/run/docker.sock:/var/run/docker.sock"
        -w /sandbox
    )

    # Add node user to docker group by setting group ID of docker socket
    if [[ -S "/var/run/docker.sock" ]]; then
        local docker_gid
        docker_gid=$(stat -f '%g' /var/run/docker.sock 2>/dev/null || stat -c '%g' /var/run/docker.sock 2>/dev/null || echo "")
        if [[ -n "${docker_gid}" ]]; then
            docker_args+=(--group-add "${docker_gid}")
        fi
    fi

    # Add network restrictions if requested
    if [[ "${no_network}" == "true" ]]; then
        docker_args+=(--cap-add=NET_ADMIN)
        print_warning "Network restrictions enabled. Running firewall initialization..."
    fi

    # Set the command
    if [[ "${shell_mode}" == "true" ]]; then
        docker_args+=("${image_name}" "/bin/zsh")
    else
        if [[ "${no_network}" == "true" ]]; then
            docker_args+=("${image_name}" "/bin/bash" "-c" "sudo /usr/local/bin/init-firewall.sh && claude --dangerously-skip-permissions")
        else
            docker_args+=("${image_name}" "claude" "--dangerously-skip-permissions")
        fi
    fi

    # Run the container
    docker "${docker_args[@]}"
}

# Show project status
show_status() {
    local project_name
    project_name=$(get_project_name)
    local image_name
    image_name=$(get_image_name)
    local container_name
    container_name=$(get_container_name)
    local secrets_dir="${CCC_SECRETS_BASE}/${project_name}"
    local ccc_dir="./ccc"

    echo "=== CCC Status for: ${project_name} ==="
    echo ""

    # Check initialization
    if [[ -d "${ccc_dir}" ]]; then
        print_success "Project initialized: ${ccc_dir}"
    else
        print_warning "Project not initialized. Run 'ccc init'"
    fi

    # Check Dockerfile
    if [[ -f "${ccc_dir}/Dockerfile.devcontainer" ]]; then
        print_success "Dockerfile exists: ${ccc_dir}/Dockerfile.devcontainer"
    else
        print_warning "Dockerfile missing"
    fi

    # Check Docker image
    if docker image inspect "${image_name}" &> /dev/null; then
        local image_size
        image_size=$(docker image inspect "${image_name}" --format='{{.Size}}' | numfmt --to=iec 2>/dev/null || echo "unknown")
        print_success "Docker image exists: ${image_name} (${image_size})"
    else
        print_warning "Docker image not built: ${image_name}"
    fi

    # Check if container is running
    if docker ps --format '{{.Names}}' | grep -q "^${container_name}$"; then
        print_success "Container running: ${container_name}"
    else
        print_info "Container not running: ${container_name}"
    fi

    # Check secrets directory
    if [[ -d "${secrets_dir}" ]]; then
        local secret_count
        secret_count=$(find "${secrets_dir}" -type f 2>/dev/null | wc -l | tr -d ' ')
        print_success "Secrets directory: ${secrets_dir} (${secret_count} files)"
    else
        print_info "Secrets directory not created: ${secrets_dir}"
    fi

    echo ""
}

# Clean up project resources
clean_project() {
    local project_name
    project_name=$(get_project_name)
    local image_name
    image_name=$(get_image_name)
    local container_name
    container_name=$(get_container_name)

    print_info "Cleaning up resources for: ${project_name}"

    # Stop container if running
    if docker ps --format '{{.Names}}' | grep -q "^${container_name}$"; then
        print_info "Stopping container: ${container_name}"
        docker stop "${container_name}"
    fi

    # Remove image if exists
    if docker image inspect "${image_name}" &> /dev/null; then
        print_info "Removing image: ${image_name}"
        docker rmi "${image_name}"
        print_success "Image removed"
    else
        print_info "Image not found: ${image_name}"
    fi

    print_success "Cleanup complete"
}

# Main function
main() {
    local force_build=false
    local shell_mode=false
    local no_network=false
    local command=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--version)
                echo "ccc version ${CCC_VERSION}"
                exit 0
                ;;
            -b|--build)
                force_build=true
                shift
                ;;
            -n|--no-network)
                no_network=true
                shift
                ;;
            --shell)
                shell_mode=true
                shift
                ;;
            init|build|clean|status)
                command="$1"
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done

    # Check Docker availability
    check_docker

    # Execute command
    case "${command}" in
        init)
            init_project
            ;;
        build)
            build_image "true"
            ;;
        clean)
            clean_project
            ;;
        status)
            show_status
            ;;
        "")
            # Default: run container
            if [[ "${force_build}" == "true" ]]; then
                build_image "true"
            fi
            run_container "${shell_mode}" "${no_network}"
            ;;
    esac
}

# Run main
main "$@"
