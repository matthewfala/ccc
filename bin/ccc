#!/usr/bin/env bash
#
# ccc - Claude Code Container
# A tool to run Claude Code in a sandboxed Docker container
#
# Copyright (c) Matthew Fala. All Rights Reserved.
#

set -euo pipefail

# Configuration
CCC_VERSION="1.1.9"
CCC_IMAGE_PREFIX="ccc-devcontainer"
CCC_BASE_DIR="${HOME}/.ccc"

# Colors for output (if terminal supports it)
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Print functions
print_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
}

# Show usage
show_usage() {
    cat << EOF
ccc - Claude Code Container v${CCC_VERSION}

Usage: ccc [OPTIONS] [COMMAND]

Run Claude Code in a sandboxed Docker container with access only to the current directory.

Options:
    -h, --help          Show this help message
    -v, --version       Show version information
    -b, --build         Force rebuild of the Docker image
    -n, --no-network    Restrict network access (enable firewall)
    --shell             Open a shell instead of Claude Code

Commands:
    init                Initialize ccc in current directory (creates /ccc folder)
    build               Build/rebuild the Docker image
    clean               Remove Docker image and container for current project
    status              Show status of current project

Examples:
    ccc                 Start Claude Code in the current directory
    ccc init            Initialize ccc configuration in current directory
    ccc --build         Force rebuild and start Claude Code
    ccc --shell         Open an interactive shell in the container

For more information, visit: https://github.com/anthropics/claude-code

EOF
}

# Get project name from current directory
get_project_name() {
    basename "$(pwd)"
}

# Get or generate a unique CCC identifier for this project
# Format: <folder-name>-<8-char-hex>
# Persisted in ./ccc/.ccc-id
get_ccc_identifier() {
    local id_file="./ccc/.ccc-id"
    if [[ -f "${id_file}" ]]; then
        local existing
        existing=$(cat "${id_file}")
        # Validate: must end with 8 hex chars (not a bare trailing dash)
        if [[ "${existing}" =~ -[0-9a-f]{8}$ ]]; then
            echo "${existing}"
            return
        fi
        # Invalid identifier from a previous buggy run — regenerate
        rm -f "${id_file}"
    fi

    local folder_name
    folder_name=$(basename "$(pwd)")
    local hash_input
    hash_input="$(pwd)-$(date +%s)-$$"
    local hash
    if command -v sha256sum &> /dev/null; then
        hash=$(printf '%s' "${hash_input}" | sha256sum | head -c 8)
    else
        hash=$(printf '%s' "${hash_input}" | shasum -a 256 | head -c 8)
    fi
    local identifier="${folder_name}-${hash}"

    # Ensure ccc directory exists before writing
    mkdir -p "./ccc"
    echo "${identifier}" > "${id_file}"
    echo "${identifier}"
}

# Get image name for current project
get_image_name() {
    local identifier
    identifier=$(get_ccc_identifier)
    echo "${CCC_IMAGE_PREFIX}-${identifier}"
}

# Get container name for current project
get_container_name() {
    local identifier
    identifier=$(get_ccc_identifier)
    echo "ccc-${identifier}"
}

# Get project-specific paths for persistence
# All project data is now stored under ~/.ccc/<identifier>/
get_project_paths() {
    local identifier
    identifier=$(get_ccc_identifier)
    local project_dir="${CCC_BASE_DIR}/${identifier}"

    # Export all paths for use by calling function
    CCC_PROJECT_DIR="${project_dir}"
    CCC_CLAUDE_CONFIG_DIR="${project_dir}/claude"
    CCC_XDG_CONFIG_DIR="${project_dir}/xdg-config"
    CCC_XDG_DATA_DIR="${project_dir}/xdg-data"
    CCC_CLAUDE_JSON_FILE="${project_dir}/claude.json"
    CCC_SECRETS_DIR="${project_dir}/sandbox-secrets"
    CCC_CONFIG_DIR="${project_dir}/configuration"
}

# Migrate data from old global paths to new project-specific paths (v1.1.7 -> v1.1.8)
migrate_old_paths() {
    local project_name
    project_name=$(get_project_name)

    # Old global paths (pre-v1.1.8)
    local old_claude_config="${HOME}/.ccc-claude-config"
    local old_xdg_config="${HOME}/.ccc-xdg-config"
    local old_xdg_data="${HOME}/.ccc-xdg-data"
    local old_claude_json="${HOME}/.ccc-claude.json"
    local old_secrets="${HOME}/Sandbox/ccc-secrets/${project_name}"

    local migrated=false

    # Migrate Claude config (authentication)
    if [[ -d "${old_claude_config}" ]] && [[ -n "$(ls -A "${old_claude_config}" 2>/dev/null)" ]]; then
        if [[ ! -d "${CCC_CLAUDE_CONFIG_DIR}" ]] || [[ -z "$(ls -A "${CCC_CLAUDE_CONFIG_DIR}" 2>/dev/null)" ]]; then
            print_info "Migrating Claude authentication from old location..."
            mkdir -p "${CCC_CLAUDE_CONFIG_DIR}"
            cp -r "${old_claude_config}"/* "${CCC_CLAUDE_CONFIG_DIR}/" 2>/dev/null || true
            migrated=true
        fi
    fi

    # Migrate XDG config
    if [[ -d "${old_xdg_config}" ]] && [[ -n "$(ls -A "${old_xdg_config}" 2>/dev/null)" ]]; then
        if [[ ! -d "${CCC_XDG_CONFIG_DIR}" ]] || [[ -z "$(ls -A "${CCC_XDG_CONFIG_DIR}" 2>/dev/null)" ]]; then
            print_info "Migrating XDG config from old location..."
            mkdir -p "${CCC_XDG_CONFIG_DIR}"
            cp -r "${old_xdg_config}"/* "${CCC_XDG_CONFIG_DIR}/" 2>/dev/null || true
            migrated=true
        fi
    fi

    # Migrate XDG data
    if [[ -d "${old_xdg_data}" ]] && [[ -n "$(ls -A "${old_xdg_data}" 2>/dev/null)" ]]; then
        if [[ ! -d "${CCC_XDG_DATA_DIR}" ]] || [[ -z "$(ls -A "${CCC_XDG_DATA_DIR}" 2>/dev/null)" ]]; then
            print_info "Migrating XDG data from old location..."
            mkdir -p "${CCC_XDG_DATA_DIR}"
            cp -r "${old_xdg_data}"/* "${CCC_XDG_DATA_DIR}/" 2>/dev/null || true
            migrated=true
        fi
    fi

    # Migrate .claude.json
    if [[ -f "${old_claude_json}" ]] && [[ -s "${old_claude_json}" ]]; then
        if [[ ! -f "${CCC_CLAUDE_JSON_FILE}" ]] || [[ ! -s "${CCC_CLAUDE_JSON_FILE}" ]] || [[ "$(cat "${CCC_CLAUDE_JSON_FILE}")" == "{}" ]]; then
            print_info "Migrating theme preferences from old location..."
            mkdir -p "$(dirname "${CCC_CLAUDE_JSON_FILE}")"
            cp "${old_claude_json}" "${CCC_CLAUDE_JSON_FILE}" 2>/dev/null || true
            migrated=true
        fi
    fi

    # Migrate secrets
    if [[ -d "${old_secrets}" ]] && [[ -n "$(ls -A "${old_secrets}" 2>/dev/null)" ]]; then
        if [[ ! -d "${CCC_SECRETS_DIR}" ]] || [[ -z "$(ls -A "${CCC_SECRETS_DIR}" 2>/dev/null)" ]]; then
            print_info "Migrating secrets from old location..."
            mkdir -p "${CCC_SECRETS_DIR}"
            cp -r "${old_secrets}"/* "${CCC_SECRETS_DIR}/" 2>/dev/null || true
            migrated=true
        fi
    fi

    if [[ "${migrated}" == "true" ]]; then
        print_success "Migration complete. Old data preserved at original locations."
        print_info "You can delete old directories after verifying the migration:"
        print_info "  ~/.ccc-claude-config, ~/.ccc-xdg-config, ~/.ccc-xdg-data"
        print_info "  ~/.ccc-claude.json, ~/Sandbox/ccc-secrets/${project_name}"
        echo ""
    fi
}

# Check if Docker is available
check_docker() {
    if ! command -v docker &> /dev/null; then
        print_error "Docker is not installed or not in PATH"
        print_info "Please install Docker: https://docs.docker.com/get-docker/"
        exit 1
    fi

    if ! docker info &> /dev/null; then
        print_error "Docker daemon is not running"
        print_info "Please start Docker and try again"
        exit 1
    fi
}

# Initialize ccc in current directory
init_project() {
    local project_name
    project_name=$(get_project_name)
    local ccc_dir="./ccc"

    print_info "Initializing ccc for project: ${project_name}"

    # Create ccc directory
    if [[ ! -d "${ccc_dir}" ]]; then
        mkdir -p "${ccc_dir}"
        print_success "Created ${ccc_dir} directory"
    else
        print_info "${ccc_dir} directory already exists"
    fi

    # Generate and persist the unique identifier
    local identifier
    identifier=$(get_ccc_identifier)
    print_success "Project identifier: ${identifier}"

    # Get project-specific paths (uses identifier)
    get_project_paths

    # Create Dockerfile.devcontainer if it doesn't exist
    if [[ ! -f "${ccc_dir}/Dockerfile.devcontainer" ]]; then
        create_default_dockerfile "${ccc_dir}/Dockerfile.devcontainer"
        print_success "Created ${ccc_dir}/Dockerfile.devcontainer"
    else
        print_info "Dockerfile.devcontainer already exists"
    fi

    # Create init-firewall.sh if it doesn't exist
    if [[ ! -f "${ccc_dir}/init-firewall.sh" ]]; then
        create_init_firewall_script "${ccc_dir}/init-firewall.sh"
        print_success "Created ${ccc_dir}/init-firewall.sh"
    else
        print_info "init-firewall.sh already exists"
    fi

    # Create entrypoint.sh if it doesn't exist
    if [[ ! -f "${ccc_dir}/entrypoint.sh" ]]; then
        create_entrypoint_script "${ccc_dir}/entrypoint.sh"
        print_success "Created ${ccc_dir}/entrypoint.sh"
    else
        print_info "entrypoint.sh already exists"
    fi

    # Create prompt capture hook scripts if they don't exist
    if [[ ! -f "${ccc_dir}/ccc-store-prompt.sh" ]] || [[ ! -f "${ccc_dir}/ccc-store-prompt.py" ]]; then
        create_store_prompt_scripts "${ccc_dir}"
        print_success "Created prompt capture hook scripts"
    else
        print_info "Hook scripts already exist"
    fi

    # Create steering file
    if [[ ! -f "${ccc_dir}/CLAUDE.md" ]]; then
        create_steering_file "${ccc_dir}/CLAUDE.md" "${identifier}"
        print_success "Created ${ccc_dir}/CLAUDE.md steering file"
    else
        print_info "CLAUDE.md steering file already exists"
    fi

    # Create project persistence directory on host (includes secrets)
    if [[ ! -d "${CCC_PROJECT_DIR}" ]]; then
        mkdir -p "${CCC_PROJECT_DIR}"
        print_success "Created project directory: ${CCC_PROJECT_DIR}"
    else
        print_info "Project directory already exists: ${CCC_PROJECT_DIR}"
    fi

    # Create secrets directory on host
    if [[ ! -d "${CCC_SECRETS_DIR}" ]]; then
        mkdir -p "${CCC_SECRETS_DIR}"
        print_success "Created secrets directory: ${CCC_SECRETS_DIR}"
    else
        print_info "Secrets directory already exists: ${CCC_SECRETS_DIR}"
    fi

    # Create configuration directory
    if [[ ! -d "${CCC_CONFIG_DIR}" ]]; then
        mkdir -p "${CCC_CONFIG_DIR}"
        print_success "Created configuration directory: ${CCC_CONFIG_DIR}"
    else
        print_info "Configuration directory already exists: ${CCC_CONFIG_DIR}"
    fi

    # Create default project-config.json if it doesn't exist
    ensure_project_config "${project_name}" "${identifier}"

    # Create .gitignore if not exists
    if [[ ! -f "${ccc_dir}/.gitignore" ]]; then
        cat > "${ccc_dir}/.gitignore" << 'GITIGNORE'
# CCC local files
*.local
.env
.ccc-id
GITIGNORE
        print_success "Created ${ccc_dir}/.gitignore"
    fi

    print_success "Project initialized! Run 'ccc' to start Claude Code in container"
}

# Create the default Dockerfile
create_default_dockerfile() {
    local dockerfile_path="$1"
    cat > "${dockerfile_path}" << 'DOCKERFILE'
FROM node:20

ARG TZ
ENV TZ="$TZ"

ARG CLAUDE_CODE_VERSION=latest

# Install basic development tools, iptables/ipset, and Docker CLI for Docker-in-Docker
RUN apt-get update && apt-get install -y --no-install-recommends \
    less \
    git \
    procps \
    sudo \
    fzf \
    zsh \
    man-db \
    unzip \
    gnupg2 \
    gh \
    iptables \
    ipset \
    iproute2 \
    dnsutils \
    aggregate \
    jq \
    nano \
    vim \
    ca-certificates \
    curl \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# Install Docker CLI for Docker-in-Docker support
RUN install -m 0755 -d /etc/apt/keyrings && \
    curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc && \
    chmod a+r /etc/apt/keyrings/docker.asc && \
    echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian $(. /etc/os-release && echo "$VERSION_CODENAME") stable" > /etc/apt/sources.list.d/docker.list && \
    apt-get update && \
    apt-get install -y --no-install-recommends docker-ce-cli docker-buildx-plugin gosu && \
    apt-get clean && rm -rf /var/lib/apt/lists/*

# Python for Google Drive prompt upload hook
RUN apt-get update && apt-get install -y --no-install-recommends \
    python3 python3-pip python3-venv \
    && apt-get clean && rm -rf /var/lib/apt/lists/*

# Google Drive API client
RUN pip3 install --no-cache-dir --break-system-packages \
    google-auth google-api-python-client

# Ensure default node user has access to /usr/local/share
RUN mkdir -p /usr/local/share/npm-global && \
    chown -R node:node /usr/local/share

ARG USERNAME=node

# Persist bash history
RUN SNIPPET="export PROMPT_COMMAND='history -a' && export HISTFILE=/commandhistory/.bash_history" \
    && mkdir /commandhistory \
    && touch /commandhistory/.bash_history \
    && chown -R $USERNAME /commandhistory

# Set DEVCONTAINER environment variable
ENV DEVCONTAINER=true

# Auto-accept Claude Code terms and dangerous permissions since we're in a container
ENV CLAUDE_CODE_ACCEPT_TOS=true

# Create workspace, secrets, and config directories (including XDG paths for persistent config)
RUN mkdir -p /sandbox /secrets /home/node/.claude /home/node/.config /home/node/.local/share /home/node/.npm && \
    chown -R node:node /sandbox /secrets /home/node/.claude /home/node/.config /home/node/.local /home/node/.npm

# Set XDG environment variables for config persistence
ENV XDG_CONFIG_HOME=/home/node/.config
ENV XDG_DATA_HOME=/home/node/.local/share

WORKDIR /sandbox

ARG GIT_DELTA_VERSION=0.18.2
RUN ARCH=$(dpkg --print-architecture) && \
    wget "https://github.com/dandavison/delta/releases/download/${GIT_DELTA_VERSION}/git-delta_${GIT_DELTA_VERSION}_${ARCH}.deb" && \
    sudo dpkg -i "git-delta_${GIT_DELTA_VERSION}_${ARCH}.deb" && \
    rm "git-delta_${GIT_DELTA_VERSION}_${ARCH}.deb"

# Set up non-root user
USER node

# Install global packages
ENV NPM_CONFIG_PREFIX=/usr/local/share/npm-global
ENV PATH=$PATH:/usr/local/share/npm-global/bin

# Set the default shell to zsh
ENV SHELL=/bin/zsh

# Set the default editor
ENV EDITOR=nano
ENV VISUAL=nano

# Default powerline10k theme
ARG ZSH_IN_DOCKER_VERSION=1.2.0
RUN sh -c "$(wget -O- https://github.com/deluan/zsh-in-docker/releases/download/v${ZSH_IN_DOCKER_VERSION}/zsh-in-docker.sh)" -- \
    -p git \
    -p fzf \
    -a "source /usr/share/doc/fzf/examples/key-bindings.zsh" \
    -a "source /usr/share/doc/fzf/examples/completion.zsh" \
    -a "export PROMPT_COMMAND='history -a' && export HISTFILE=/commandhistory/.bash_history" \
    -x

# Install Claude Code
RUN npm install -g @anthropic-ai/claude-code@${CLAUDE_CODE_VERSION}

# Copy and set up firewall script, entrypoint, and hook scripts
COPY init-firewall.sh /usr/local/bin/
COPY entrypoint.sh /usr/local/bin/
COPY ccc-store-prompt.sh /usr/local/bin/
COPY ccc-store-prompt.py /usr/local/bin/
USER root
RUN chmod +x /usr/local/bin/init-firewall.sh /usr/local/bin/entrypoint.sh \
    /usr/local/bin/ccc-store-prompt.sh /usr/local/bin/ccc-store-prompt.py && \
    echo "node ALL=(root) NOPASSWD: /usr/local/bin/init-firewall.sh" > /etc/sudoers.d/node-firewall && \
    echo "node ALL=(root) NOPASSWD: ALL" > /etc/sudoers.d/node-sudo && \
    chmod 0440 /etc/sudoers.d/node-firewall && \
    chmod 0440 /etc/sudoers.d/node-sudo

# Use entrypoint to fix docker socket permissions before switching to node user
ENTRYPOINT ["/usr/local/bin/entrypoint.sh"]

# Default command
CMD ["claude", "--dangerously-skip-permissions"]
DOCKERFILE
}

# Create init-firewall.sh script
create_init_firewall_script() {
    local script_path="$1"
    cat > "${script_path}" << 'FIREWALL_SCRIPT'
#!/bin/bash
set -euo pipefail
IFS=$'\n\t'

# Extract Docker DNS info BEFORE any flushing
DOCKER_DNS_RULES=$(iptables-save -t nat | grep "127\.0\.0\.11" || true)

# Flush existing rules and delete existing ipsets
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
ipset destroy allowed-domains 2>/dev/null || true

# Restore Docker DNS resolution
if [ -n "$DOCKER_DNS_RULES" ]; then
    echo "Restoring Docker DNS rules..."
    iptables -t nat -N DOCKER_OUTPUT 2>/dev/null || true
    iptables -t nat -N DOCKER_POSTROUTING 2>/dev/null || true
    echo "$DOCKER_DNS_RULES" | xargs -L 1 iptables -t nat
else
    echo "No Docker DNS rules to restore"
fi

# Allow DNS and localhost before restrictions
iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
iptables -A INPUT -p udp --sport 53 -j ACCEPT
iptables -A OUTPUT -p tcp --dport 22 -j ACCEPT
iptables -A INPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# Create ipset with CIDR support
ipset create allowed-domains hash:net

# Fetch GitHub meta information
echo "Fetching GitHub IP ranges..."
gh_ranges=$(curl -s https://api.github.com/meta)
if [ -z "$gh_ranges" ]; then
    echo "ERROR: Failed to fetch GitHub IP ranges"
    exit 1
fi

if ! echo "$gh_ranges" | jq -e '.web and .api and .git' >/dev/null; then
    echo "ERROR: GitHub API response missing required fields"
    exit 1
fi

echo "Processing GitHub IPs..."
while read -r cidr; do
    if [[ ! "$cidr" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$ ]]; then
        echo "ERROR: Invalid CIDR range from GitHub meta: $cidr"
        exit 1
    fi
    echo "Adding GitHub range $cidr"
    ipset add allowed-domains "$cidr"
done < <(echo "$gh_ranges" | jq -r '(.web + .api + .git)[]' | aggregate -q)

# Resolve and add other allowed domains
for domain in \
    "registry.npmjs.org" \
    "api.anthropic.com" \
    "sentry.io" \
    "statsig.anthropic.com" \
    "statsig.com" \
    "marketplace.visualstudio.com" \
    "vscode.blob.core.windows.net" \
    "update.code.visualstudio.com"; do
    echo "Resolving $domain..."
    ips=$(dig +noall +answer A "$domain" | awk '$4 == "A" {print $5}')
    if [ -z "$ips" ]; then
        echo "ERROR: Failed to resolve $domain"
        exit 1
    fi

    while read -r ip; do
        if [[ ! "$ip" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            echo "ERROR: Invalid IP from DNS for $domain: $ip"
            exit 1
        fi
        echo "Adding $ip for $domain"
        ipset add allowed-domains "$ip"
    done < <(echo "$ips")
done

# Get host IP from default route
HOST_IP=$(ip route | grep default | cut -d" " -f3)
if [ -z "$HOST_IP" ]; then
    echo "ERROR: Failed to detect host IP"
    exit 1
fi

HOST_NETWORK=$(echo "$HOST_IP" | sed "s/\.[0-9]*$/.0\/24/")
echo "Host network detected as: $HOST_NETWORK"

# Set up remaining iptables rules
iptables -A INPUT -s "$HOST_NETWORK" -j ACCEPT
iptables -A OUTPUT -d "$HOST_NETWORK" -j ACCEPT

# Set default policies to DROP
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT DROP

# Allow established connections
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Allow outbound traffic to allowed domains
iptables -A OUTPUT -m set --match-set allowed-domains dst -j ACCEPT

# Reject other outbound traffic
iptables -A OUTPUT -j REJECT --reject-with icmp-admin-prohibited

echo "Firewall configuration complete"
FIREWALL_SCRIPT
    chmod +x "${script_path}"
}

# Create entrypoint script that fixes docker socket permissions
create_entrypoint_script() {
    local script_path="$1"
    cat > "${script_path}" << 'ENTRYPOINT_SCRIPT'
#!/bin/bash
set -e

# Fix docker socket permissions if it exists
if [ -S /var/run/docker.sock ]; then
    chmod 666 /var/run/docker.sock 2>/dev/null || true
fi

# Fix ownership of mounted config directories so node user can write to them
# Note: .npm is NOT mounted - only Claude-related data is persisted
chown -R node:node /home/node/.claude 2>/dev/null || true
chown -R node:node /home/node/.config 2>/dev/null || true
chown -R node:node /home/node/.local 2>/dev/null || true
chown node:node /home/node/.claude.json 2>/dev/null || true

# Ensure the directories exist with correct permissions
mkdir -p /home/node/.claude /home/node/.config /home/node/.local/share
chown -R node:node /home/node/.claude /home/node/.config /home/node/.local

# Create default settings.json if it doesn't exist (for container environment)
if [ ! -f /home/node/.claude/settings.json ]; then
    cat > /home/node/.claude/settings.json << 'SETTINGS'
{
  "permissions": {
    "defaultMode": "bypassPermissions"
  },
  "env": {
    "CLAUDE_CODE_ACCEPT_TOS": "1"
  }
}
SETTINGS
    chown node:node /home/node/.claude/settings.json
fi

# Create default .claude.json with dark theme if it doesn't exist
if [ ! -s /home/node/.claude.json ] || [ "$(cat /home/node/.claude.json)" = "{}" ]; then
    cat > /home/node/.claude.json << 'CLAUDEJSON'
{
  "theme": "dark",
  "hasCompletedOnboarding": true
}
CLAUDEJSON
    chown node:node /home/node/.claude.json
fi

# Inject prompt capture hook if Google Drive is enabled
if [ -f /config/project-config.json ]; then
    DRIVE_ENABLED=$(jq -r '.googleDrive.enabled // false' /config/project-config.json 2>/dev/null)
    if [ "$DRIVE_ENABLED" = "true" ]; then
        # Add UserPromptSubmit hook to settings.json
        SETTINGS_FILE="/home/node/.claude/settings.json"
        if [ -f "$SETTINGS_FILE" ]; then
            jq '.hooks = (.hooks // {}) | .hooks.UserPromptSubmit = [{
                "hooks": [{
                    "type": "command",
                    "command": "/usr/local/bin/ccc-store-prompt.sh"
                }]
            }]' "$SETTINGS_FILE" > /tmp/settings.tmp && mv /tmp/settings.tmp "$SETTINGS_FILE"
            chown node:node "$SETTINGS_FILE"
        fi
    fi
fi

# Switch to node user and execute the command
exec gosu node "$@"
ENTRYPOINT_SCRIPT
    chmod +x "${script_path}"
}

# Create prompt capture hook scripts
create_store_prompt_scripts() {
    local ccc_dir="$1"

    # Shell wrapper
    cat > "${ccc_dir}/ccc-store-prompt.sh" << 'HOOK_SHELL'
#!/bin/bash
# Hook: UserPromptSubmit
# Reads JSON from stdin, extracts prompt, uploads to Google Drive asynchronously.
# Must exit 0 immediately to avoid blocking Claude.

INPUT=$(cat)
SESSION_ID=$(echo "$INPUT" | jq -r '.session_id // empty')
PROMPT=$(echo "$INPUT" | jq -r '.prompt // empty')

if [[ -z "$PROMPT" ]]; then
    exit 0
fi

# Run upload in background -- do not block Claude
/usr/local/bin/ccc-store-prompt.py "$SESSION_ID" <<< "$PROMPT" &

exit 0
HOOK_SHELL
    chmod +x "${ccc_dir}/ccc-store-prompt.sh"

    # Python uploader
    cat > "${ccc_dir}/ccc-store-prompt.py" << 'HOOK_PYTHON'
#!/usr/bin/env python3
"""
CCC Prompt Capture - Google Drive Uploader

Reads a prompt from stdin and appends it to a session markdown file
in Google Drive. Uses service account authentication.

Usage: ccc-store-prompt.py <session_id> <<< "prompt text"

All errors are caught and logged to stderr. Never exits non-zero
to avoid interfering with Claude Code.
"""

import json
import os
import sys
from datetime import datetime


def main():
    try:
        session_id = sys.argv[1] if len(sys.argv) > 1 else ""
        prompt = sys.stdin.read().strip()

        if not prompt:
            sys.exit(0)

        config_path = "/config/project-config.json"
        if not os.path.exists(config_path):
            sys.exit(0)

        with open(config_path, "r") as f:
            config = json.load(f)

        drive_config = config.get("googleDrive", {})
        if not drive_config.get("enabled", False):
            sys.exit(0)

        credentials_path = drive_config.get("credentialsPath", "")
        prompts_folder_id = drive_config.get("promptsFolderId", "")
        identifier = config.get("cccIdentifier", "unknown")

        if not credentials_path or not prompts_folder_id:
            sys.exit(0)

        if not os.path.exists(credentials_path):
            print(f"Warning: credentials file not found: {credentials_path}", file=sys.stderr)
            sys.exit(0)

        from google.oauth2 import service_account
        from googleapiclient.discovery import build
        from googleapiclient.http import MediaInMemoryUpload

        SCOPES = ["https://www.googleapis.com/auth/drive"]
        creds = service_account.Credentials.from_service_account_file(
            credentials_path, scopes=SCOPES
        )
        service = build("drive", "v3", credentials=creds)

        folder_id = find_or_create_folder(service, prompts_folder_id, identifier)

        today = datetime.now().strftime("%Y-%m-%d")
        filename = f"session_{today}.md"

        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        entry = f"## Prompt [{timestamp}]\n\n{prompt}\n\n---\n\n"

        file_id = find_file(service, folder_id, filename)

        if file_id:
            existing_content = download_file_content(service, file_id)
            new_content = existing_content + entry
            update_file(service, file_id, new_content)
        else:
            header = f"# Prompts - {today}\n\n**Project:** {identifier}\n\n---\n\n"
            content = header + entry
            create_file(service, folder_id, filename, content)

    except Exception as e:
        print(f"ccc-store-prompt error: {e}", file=sys.stderr)
        sys.exit(0)


def find_or_create_folder(service, parent_id, folder_name):
    query = (
        f"name = '{folder_name}' and '{parent_id}' in parents "
        f"and mimeType = 'application/vnd.google-apps.folder' and trashed = false"
    )
    results = service.files().list(
        q=query, spaces="drive", fields="files(id, name)",
        supportsAllDrives=True, includeItemsFromAllDrives=True
    ).execute()
    files = results.get("files", [])
    if files:
        return files[0]["id"]
    file_metadata = {
        "name": folder_name,
        "mimeType": "application/vnd.google-apps.folder",
        "parents": [parent_id],
    }
    folder = service.files().create(
        body=file_metadata, fields="id", supportsAllDrives=True
    ).execute()
    return folder["id"]


def find_file(service, folder_id, filename):
    query = (
        f"name = '{filename}' and '{folder_id}' in parents "
        f"and mimeType != 'application/vnd.google-apps.folder' and trashed = false"
    )
    results = service.files().list(
        q=query, spaces="drive", fields="files(id, name)",
        supportsAllDrives=True, includeItemsFromAllDrives=True
    ).execute()
    files = results.get("files", [])
    return files[0]["id"] if files else None


def download_file_content(service, file_id):
    content = service.files().get_media(
        fileId=file_id, supportsAllDrives=True
    ).execute()
    return content.decode("utf-8") if isinstance(content, bytes) else content


def update_file(service, file_id, content):
    from googleapiclient.http import MediaInMemoryUpload
    media = MediaInMemoryUpload(
        content.encode("utf-8"), mimetype="text/markdown"
    )
    service.files().update(
        fileId=file_id, media_body=media, supportsAllDrives=True
    ).execute()


def create_file(service, folder_id, filename, content):
    from googleapiclient.http import MediaInMemoryUpload
    file_metadata = {
        "name": filename,
        "parents": [folder_id],
    }
    media = MediaInMemoryUpload(
        content.encode("utf-8"), mimetype="text/markdown"
    )
    service.files().create(
        body=file_metadata, media_body=media, fields="id",
        supportsAllDrives=True
    ).execute()


if __name__ == "__main__":
    main()
HOOK_PYTHON
    chmod +x "${ccc_dir}/ccc-store-prompt.py"
}

# Create steering file for Claude Code
create_steering_file() {
    local steering_path="$1"
    local identifier="$2"
    cat > "${steering_path}" << STEERING
# Claude Code Container Steering File

## Container Environment

You are running inside a sandboxed Docker container via **ccc** (Claude Code Container).
Your workspace is mounted at \`/sandbox\` which corresponds to the host's project directory.

## Important Guidelines

### File System Restrictions
- You can ONLY modify files within \`/sandbox\` (the mounted project directory)
- Do NOT attempt to modify system files or directories outside \`/sandbox\`
- All your work should be contained within the project directory

### Secrets Management
- A secrets directory is mounted at \`/secrets\` for storing sensitive data
- Use \`/secrets\` for API keys, credentials, and other sensitive information that should NOT be committed to git
- The secrets directory persists between container restarts
- Location on host: \`~/.ccc/${identifier}/sandbox-secrets\`

### Configuration
- A read-only configuration directory is mounted at \`/config\`
- Contains \`project-config.json\` with Google Drive integration settings
- Contains \`drive-credentials.json\` for Google service account (if configured)
- To modify configuration, edit files on the host at: \`~/.ccc/${identifier}/configuration/\`

### Container OS Changes (Docker-in-Docker) - AUTOMATIC PERSISTENCE

**IMPORTANT**: When you install any software or tools that need to persist across container restarts, you MUST:

1. **Automatically edit the Dockerfile**: Modify \`/sandbox/ccc/Dockerfile.devcontainer\` to add the required packages
2. **Document changes**: Add comments explaining why each package is needed
3. **Rebuild from within the container**: Use Docker-in-Docker to rebuild the image:
   \`\`\`bash
   cd /sandbox/ccc && docker build -t ${CCC_IMAGE_PREFIX}-${identifier} -f Dockerfile.devcontainer .
   \`\`\`
4. **If the build fails**: Fix the Dockerfile and try rebuilding again until successful

**This decision to persist software should be made AUTOMATICALLY by you. Do NOT ask the user if they want to persist - just do it.**

Example addition to Dockerfile:
\`\`\`dockerfile
# Install Python for data processing scripts
RUN apt-get update && apt-get install -y python3 python3-pip && \\
    apt-get clean && rm -rf /var/lib/apt/lists/*
\`\`\`

Docker is available inside this container via Docker-in-Docker. The docker socket permissions are automatically configured at container startup.

### Network Access
- By default, network access is unrestricted
- If running with \`--no-network\`, only specific domains are accessible:
  - api.anthropic.com
  - github.com
  - registry.npmjs.org
  - And a few others for essential operations

### Best Practices
1. Keep all project files in \`/sandbox\`
2. Store secrets in \`/secrets\`, never in the project directory
3. Document any Dockerfile changes clearly
4. Avoid modifying container state directly; prefer Dockerfile changes for persistence

## Project Structure
\`\`\`
/sandbox/                    # Your project (mounted from host)
├── ccc/
│   ├── Dockerfile.devcontainer  # Customize your container here
│   ├── init-firewall.sh         # Network firewall script
│   └── CLAUDE.md                # This steering file
├── [your project files]
/secrets/                    # Persistent secrets storage (mounted)
/config/                     # Read-only configuration (mounted)
│   ├── project-config.json      # Project and Drive settings
│   └── drive-credentials.json   # Google service account key (if configured)
\`\`\`
STEERING
}

# Ensure project-config.json exists with defaults
ensure_project_config() {
    local project_name="$1"
    local identifier="$2"

    if [[ ! -f "${CCC_CONFIG_DIR}/project-config.json" ]]; then
        cat > "${CCC_CONFIG_DIR}/project-config.json" << CONFIGEOF
{
  "projectName": "${project_name}",
  "cccIdentifier": "${identifier}",
  "googleDrive": {
    "enabled": false,
    "credentialsPath": "/config/drive-credentials.json",
    "documentsFolderId": "",
    "promptsFolderId": ""
  }
}
CONFIGEOF
        print_success "Created default project-config.json"
    fi
}

# Ensure steering file exists at project root for Claude to read
ensure_steering_file_at_root() {
    local identifier
    identifier=$(get_ccc_identifier)
    local ccc_dir="./ccc"
    local root_steering_file="./CLAUDE.md"
    local ccc_steering_file="${ccc_dir}/CLAUDE.md"

    # If CCC steering file doesn't exist, create it
    if [[ ! -f "${ccc_steering_file}" ]]; then
        mkdir -p "${ccc_dir}"
        create_steering_file "${ccc_steering_file}" "${identifier}"
    fi

    # Create/update symlink or copy at project root if it doesn't exist or is outdated
    if [[ ! -f "${root_steering_file}" ]]; then
        # Create symlink to ccc steering file at project root
        ln -sf "ccc/CLAUDE.md" "${root_steering_file}"
        print_info "Created steering file symlink at project root: ${root_steering_file}"
    elif [[ -L "${root_steering_file}" ]]; then
        # It's already a symlink, verify it points to our file
        local target
        target=$(readlink "${root_steering_file}" 2>/dev/null || echo "")
        if [[ "${target}" != "ccc/CLAUDE.md" ]]; then
            print_warning "CLAUDE.md exists but points elsewhere. Steering file in ccc/CLAUDE.md available."
        fi
    else
        # It's a regular file, don't overwrite - just inform
        print_info "Project has custom CLAUDE.md. Container steering available in ccc/CLAUDE.md"
    fi
}

# Ensure all required ccc files exist (for upgrades from older versions)
ensure_ccc_files() {
    local ccc_dir="./ccc"
    local identifier
    identifier=$(get_ccc_identifier)

    # Always update entrypoint.sh to get latest fixes (small generated file)
    create_entrypoint_script "${ccc_dir}/entrypoint.sh"

    # Ensure init-firewall.sh exists
    if [[ ! -f "${ccc_dir}/init-firewall.sh" ]]; then
        create_init_firewall_script "${ccc_dir}/init-firewall.sh"
        print_info "Created missing ${ccc_dir}/init-firewall.sh"
    fi

    # Ensure Dockerfile.devcontainer exists
    if [[ ! -f "${ccc_dir}/Dockerfile.devcontainer" ]]; then
        create_default_dockerfile "${ccc_dir}/Dockerfile.devcontainer"
        print_info "Created missing ${ccc_dir}/Dockerfile.devcontainer"
    fi

    # Always update hook scripts to get latest fixes (small generated files)
    create_store_prompt_scripts "${ccc_dir}"
}

# Build Docker image
build_image() {
    local force_build="${1:-false}"
    local project_name
    project_name=$(get_project_name)
    local image_name
    image_name=$(get_image_name)
    local ccc_dir="./ccc"

    # Check if ccc is initialized
    if [[ ! -d "${ccc_dir}" ]]; then
        print_warning "Project not initialized. Running init first..."
        init_project
    else
        # Ensure all required files exist (handles upgrades from older versions)
        ensure_ccc_files
    fi

    # Check if image exists and we're not forcing rebuild
    if [[ "${force_build}" != "true" ]] && docker image inspect "${image_name}" &> /dev/null; then
        print_info "Image ${image_name} already exists. Use --build to force rebuild."
        return 0
    fi

    print_info "Building Docker image: ${image_name}"

    # Build the image
    docker build \
        --build-arg TZ="$(cat /etc/timezone 2>/dev/null || echo 'UTC')" \
        -t "${image_name}" \
        -f "${ccc_dir}/Dockerfile.devcontainer" \
        "${ccc_dir}"

    print_success "Image built successfully: ${image_name}"
}

# Run Claude Code in container
run_container() {
    local shell_mode="${1:-false}"
    local no_network="${2:-false}"
    local project_name
    project_name=$(get_project_name)
    local image_name
    image_name=$(get_image_name)
    local container_name
    container_name=$(get_container_name)

    # Get project-specific paths
    get_project_paths

    # Get the identifier for the banner
    local identifier
    identifier=$(get_ccc_identifier)

    # Ensure image is built
    build_image "false"

    # Ensure project directory exists
    mkdir -p "${CCC_PROJECT_DIR}"

    # Ensure secrets directory exists
    mkdir -p "${CCC_SECRETS_DIR}"

    # Ensure configuration directory exists with default config
    mkdir -p "${CCC_CONFIG_DIR}"
    ensure_project_config "${project_name}" "${identifier}"

    # Ensure Claude config directory exists
    mkdir -p "${CCC_CLAUDE_CONFIG_DIR}"

    # Ensure XDG config directories exist (for Claude Code settings persistence)
    mkdir -p "${CCC_XDG_CONFIG_DIR}"
    mkdir -p "${CCC_XDG_DATA_DIR}"

    # Ensure .claude.json file exists (stores theme and other preferences)
    if [[ ! -f "${CCC_CLAUDE_JSON_FILE}" ]]; then
        echo '{}' > "${CCC_CLAUDE_JSON_FILE}"
    fi

    # Migrate data from old global paths (v1.1.7 and earlier) to new project-specific paths
    migrate_old_paths

    # Ensure steering file exists at project root for Claude to read on startup
    ensure_steering_file_at_root

    # Display version on startup
    echo ""
    echo -e "${BLUE}╔══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${BLUE}║${NC}       ${GREEN}Claude Code Container (ccc) v${CCC_VERSION}${NC}                   ${BLUE}║${NC}"
    echo -e "${BLUE}║${NC}       Project: ${YELLOW}${project_name}${NC}                                      ${BLUE}║${NC}"
    echo -e "${BLUE}║${NC}       ID: ${YELLOW}${identifier}${NC}                                              ${BLUE}║${NC}"
    echo -e "${BLUE}╚══════════════════════════════════════════════════════════════╝${NC}"
    echo ""

    print_info "Starting Claude Code Container for: ${project_name} (${identifier})"

    # Build docker run command
    # Note: Node.js config (.npm) is NOT persisted - only Claude-related data
    local docker_args=(
        run
        --rm
        -it
        --name "${container_name}"
        -v "$(pwd):/sandbox"
        -v "${CCC_SECRETS_DIR}:/secrets"
        -v "${CCC_CLAUDE_CONFIG_DIR}:/home/node/.claude"
        -v "${CCC_XDG_CONFIG_DIR}:/home/node/.config"
        -v "${CCC_XDG_DATA_DIR}:/home/node/.local/share"
        -v "${CCC_CLAUDE_JSON_FILE}:/home/node/.claude.json"
        -v "${CCC_CONFIG_DIR}:/config:ro"
        -v "/var/run/docker.sock:/var/run/docker.sock"
        -w /sandbox
    )

    # Add node user to docker group by setting group ID of docker socket
    if [[ -S "/var/run/docker.sock" ]]; then
        local docker_gid
        docker_gid=$(stat -f '%g' /var/run/docker.sock 2>/dev/null || stat -c '%g' /var/run/docker.sock 2>/dev/null || echo "")
        if [[ -n "${docker_gid}" ]]; then
            docker_args+=(--group-add "${docker_gid}")
        fi
    fi

    # Add network restrictions if requested
    if [[ "${no_network}" == "true" ]]; then
        docker_args+=(--cap-add=NET_ADMIN)
        print_warning "Network restrictions enabled. Running firewall initialization..."
    fi

    # Set the command
    if [[ "${shell_mode}" == "true" ]]; then
        docker_args+=("${image_name}" "/bin/zsh")
    else
        if [[ "${no_network}" == "true" ]]; then
            docker_args+=("${image_name}" "/bin/bash" "-c" "sudo /usr/local/bin/init-firewall.sh && claude --dangerously-skip-permissions")
        else
            docker_args+=("${image_name}" "claude" "--dangerously-skip-permissions")
        fi
    fi

    # Run the container
    docker "${docker_args[@]}"
}

# Show project status
show_status() {
    local project_name
    project_name=$(get_project_name)
    local identifier
    identifier=$(get_ccc_identifier)
    local image_name
    image_name=$(get_image_name)
    local container_name
    container_name=$(get_container_name)
    local ccc_dir="./ccc"

    # Get project-specific paths
    get_project_paths

    echo "=== CCC Status for: ${project_name} (${identifier}) ==="
    echo ""

    # Check initialization
    if [[ -d "${ccc_dir}" ]]; then
        print_success "Project initialized: ${ccc_dir}"
    else
        print_warning "Project not initialized. Run 'ccc init'"
    fi

    # Show identifier
    print_info "Identifier: ${identifier}"

    # Check Dockerfile
    if [[ -f "${ccc_dir}/Dockerfile.devcontainer" ]]; then
        print_success "Dockerfile exists: ${ccc_dir}/Dockerfile.devcontainer"
    else
        print_warning "Dockerfile missing"
    fi

    # Check Docker image
    if docker image inspect "${image_name}" &> /dev/null; then
        local image_size
        image_size=$(docker image inspect "${image_name}" --format='{{.Size}}' | numfmt --to=iec 2>/dev/null || echo "unknown")
        print_success "Docker image exists: ${image_name} (${image_size})"
    else
        print_warning "Docker image not built: ${image_name}"
    fi

    # Check if container is running
    if docker ps --format '{{.Names}}' | grep -q "^${container_name}$"; then
        print_success "Container running: ${container_name}"
    else
        print_info "Container not running: ${container_name}"
    fi

    # Check project persistence directory
    if [[ -d "${CCC_PROJECT_DIR}" ]]; then
        print_success "Project data directory: ${CCC_PROJECT_DIR}"
    else
        print_info "Project data directory not created: ${CCC_PROJECT_DIR}"
    fi

    # Check secrets directory
    if [[ -d "${CCC_SECRETS_DIR}" ]]; then
        local secret_count
        secret_count=$(find "${CCC_SECRETS_DIR}" -type f 2>/dev/null | wc -l | tr -d ' ')
        print_success "Secrets directory: ${CCC_SECRETS_DIR} (${secret_count} files)"
    else
        print_info "Secrets directory not created: ${CCC_SECRETS_DIR}"
    fi

    # Check configuration directory and Drive status
    if [[ -d "${CCC_CONFIG_DIR}" ]]; then
        print_success "Configuration directory: ${CCC_CONFIG_DIR}"
        if [[ -f "${CCC_CONFIG_DIR}/project-config.json" ]]; then
            local drive_enabled
            drive_enabled=$(jq -r '.googleDrive.enabled // false' "${CCC_CONFIG_DIR}/project-config.json" 2>/dev/null || echo "false")
            if [[ "${drive_enabled}" == "true" ]]; then
                print_success "Google Drive integration: enabled"
            else
                print_info "Google Drive integration: disabled"
            fi
        fi
    else
        print_info "Configuration directory not created: ${CCC_CONFIG_DIR}"
    fi

    echo ""
}

# Clean up project resources
clean_project() {
    local project_name
    project_name=$(get_project_name)
    local identifier
    identifier=$(get_ccc_identifier)
    local image_name
    image_name=$(get_image_name)
    local container_name
    container_name=$(get_container_name)

    print_info "Cleaning up resources for: ${project_name} (${identifier})"

    # Stop container if running
    if docker ps --format '{{.Names}}' | grep -q "^${container_name}$"; then
        print_info "Stopping container: ${container_name}"
        docker stop "${container_name}"
    fi

    # Remove image if exists
    if docker image inspect "${image_name}" &> /dev/null; then
        print_info "Removing image: ${image_name}"
        docker rmi "${image_name}"
        print_success "Image removed"
    else
        print_info "Image not found: ${image_name}"
    fi

    print_success "Cleanup complete"
}

# Main function
main() {
    local force_build=false
    local shell_mode=false
    local no_network=false
    local command=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--version)
                echo "ccc version ${CCC_VERSION}"
                exit 0
                ;;
            -b|--build)
                force_build=true
                shift
                ;;
            -n|--no-network)
                no_network=true
                shift
                ;;
            --shell)
                shell_mode=true
                shift
                ;;
            init|build|clean|status)
                command="$1"
                shift
                ;;
            *)
                print_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done

    # Check Docker availability
    check_docker

    # Execute command
    case "${command}" in
        init)
            init_project
            ;;
        build)
            build_image "true"
            ;;
        clean)
            clean_project
            ;;
        status)
            show_status
            ;;
        "")
            # Default: run container
            if [[ "${force_build}" == "true" ]]; then
                build_image "true"
            fi
            run_container "${shell_mode}" "${no_network}"
            ;;
    esac
}

# Run main
main "$@"
